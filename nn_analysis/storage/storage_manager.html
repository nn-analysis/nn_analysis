<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nn_analysis.storage.storage_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nn_analysis.storage.storage_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import shutil

import numpy as np

from .table_set import TableSet
from .table import Table
from .error import NoSuchTableError
from .database import Database
from .helpers import __verify_data_types_are_correct__


class StorageManager:
    &#34;&#34;&#34;
    Class handling often used storage related queries such as saving results from an experiment or from fitting to a `TableSet`

    Args:
        database: `Database` the `Table`s and `TableSet`s should reside in
    &#34;&#34;&#34;

    database: Database

    def __init__(self, database: Database):
        self.database = database

    def save_result_table_set(self, results: tuple, name: str, table_labels: dict, nrows: int = None,
                              ncols: tuple = None, row_start: int = 0, col_start: int = 0,
                              append_rows: bool = False) -&gt; TableSet:
        &#34;&#34;&#34;
        Function that saves a `TableSet` with the results.
        Results do not have to be complete. If the result is incomplete provide the nrows or ncols parameters.
        The lacking rows or columns will then be filled with zeros. When providing the additional results use the
        row_start and col_start parameters to indicate where the existing TableSet is to be overridden.

        If a result tuple is incomplete and has completely missing parts fill in the missing parts with None values.

        Examples
        ---------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;})
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, nrows=4)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data appended with two rows of zeros in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, ncols=(6,))
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows and four columns of data appended with two columns of zeros in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, row_start=2)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was changed in rows 2 and 3 with the data given here.
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, append_rows=True)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was appended with the two rows given here.

        Args:
            results: A (nested) tuple of np.ndarrays containing results
            name: (str) The name of the `TableSet` to be created or updated
            table_labels: A (nested) dictionary of the names of the `Table`s/`SubTable`s in the `TableSet`
            nrows (optional): Amount of rows that will (eventually) be in the `TableSet`. If not provided `nrows=results.shape[0]`
            ncols (optional): Amount of columns that will (eventually) be in the table set per subpart of the data. If not provided `ncols[i]=results[i].shape[1]`
            row_start (optional, default=0): Int of the row where the results start. This parameter is used if nrows does not match the amount of rows in the results.
            col_start (optional, default=0): Int of the column where the results start. This parameter is used if ncols does not match the amount of columns in the results.
            append_rows (optional, default=False): If true, when the `TableSet` is already initialised the results will be appended as rows to the existing `TableSet`

        Returns:
            `TableSet` containing the results
        &#34;&#34;&#34;
        table_set = TableSet(name, self.database)
        if not __verify_data_types_are_correct__(results):
            raise ValueError(&#39;results is not a tuple of nested tuples of np.ndarrays or a tuple of np.ndarrays!&#39;)
        if not self.__verify_results_and_ncols_shape(results, ncols):
            raise ValueError(&#39;ncols and results should be of the same shape&#39;)
        if self.__requires_nrows_calculation(results, nrows):
            nrows = self.__fetch_nrows_from_partial_result_set(results)
        if ncols is None and self.__requires_ncols_to_be_set_somewhere(results):
            raise ValueError(&#39;When one of the results is None, ncols has to be set for that result!&#39;)
        padded_results = self.__pad_with_zeros(results, ncols, nrows)
        if table_set.initialised:  # Update existing TableSet
            if append_rows:
                table_set.append_rows(padded_results)
            else:
                # Combine the small arrays into one large array so we can use the TableSet update function
                combined_results = self.__combine_into_big_array(padded_results)
                table_set[row_start:combined_results.shape[0]+row_start,
                          col_start:combined_results.shape[1]+col_start] = combined_results
        else:
            table_set.initialise(padded_results, table_labels)
        return table_set

    def open_table(self, name: str):
        &#34;&#34;&#34;
        Opens a `Table` or `TableSet` in the `Database` with the given name.
        The function can automatically distinguish between `Table`s and `TableSet`s.

        Examples
        ----------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).open_table(&#39;Name&#39;)
        Table(&#39;Name&#39;) or TableSet(&#39;Name&#39;) if a `Table` or `TableSet` exists in this database.

        Args:
            name: Name of the `Table` or `TableSet`

        Returns:
            `Table` or `TableSet`
        &#34;&#34;&#34;
        if Table(name, self.database).initialised:
            return Table(name, self.database)
        elif TableSet(name, self.database).initialised:
            return TableSet(name, self.database)
        else:
            raise NoSuchTableError

    def remove_table(self, name: str):
        &#34;&#34;&#34;
        Deletes a table from the `Database`

        Examples
        ----------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).remove_table(&#39;Name&#39;)
        Removes table with the name &#39;Name&#39; from the database at path &#39;path&#39;.

        Args:
            name: The name of the `Table`
        &#34;&#34;&#34;
        if os.path.isdir(self.database.folder + name):
            shutil.rmtree(self.database.folder + name)

    def __requires_nrows_calculation(self, results: tuple, nrows: int = None) -&gt; bool:
        if nrows is not None:
            return False
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                if not self.__requires_nrows_calculation(result):
                    return False
            elif result is None:
                return True
        return False

    def __requires_ncols_to_be_set_somewhere(self, results: tuple):
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                if not self.__requires_nrows_calculation(result):
                    return False
            elif result is None:
                return True
        return False

    def __fetch_nrows_from_partial_result_set(self, results: tuple) -&gt; int:
        for result in results:
            if type(result) is tuple:
                nrows_subresult = self.__fetch_nrows_from_partial_result_set(result)
                if nrows_subresult is not None:
                    return nrows_subresult
            elif result is not None:
                return result.shape[0]
        raise ValueError(&#39;When all results are None values nrows has to be set!&#39;)

    def __verify_results_and_ncols_shape(self, results: tuple, ncols: tuple):
        if ncols is None:
            return True
        if len(ncols) != len(results):
            return False
        i = 0
        for result in results:
            if type(result) is tuple:
                if type(ncols[i]) is not tuple:
                    return False
                if not self.__verify_results_and_ncols_shape(result, ncols[i]):
                    return False
            i += 1
        return True

    def __pad_with_zeros(self, results: tuple, ncols: tuple, nrows: int) -&gt; tuple:
        i = 0
        final_result = []
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                this_ncols = ncols
                if ncols is not None:
                    this_ncols = ncols[i]
                final_result.append(self.__pad_with_zeros(result, this_ncols, nrows))
            elif result is None:  # If the result is None fill the result using the ncols and nrows
                if ncols is None or ncols[i] is None:
                    raise ValueError(&#39;When a particular result is None, ncols for that result has to be set!&#39;)
                final_result.append(np.zeros((nrows, ncols[i])))
            else:  # If the result is a result fit it in a padded result array of shape (ncols, nrows)
                flattened_array = result.reshape(result.shape[0], -1)
                this_nrows = flattened_array.shape[0]
                this_ncols = flattened_array.shape[1]
                if nrows is not None:
                    this_nrows = nrows
                if ncols is not None:
                    this_ncols = ncols[i]
                padded_array = np.zeros((this_nrows, this_ncols))
                padded_array[:, :flattened_array.shape[1]] = flattened_array
                final_result.append(padded_array)
            i += 1
        return tuple(final_result)

    def __combine_into_big_array(self, results: tuple) -&gt; np.ndarray:
        final_result = []
        for result in results:
            if type(result) is tuple:
                final_result.append(self.__combine_into_big_array(result))
            elif result is None:
                continue
            else:
                final_result.append(result)
        return np.concatenate(final_result)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nn_analysis.storage.storage_manager.StorageManager"><code class="flex name class">
<span>class <span class="ident">StorageManager</span></span>
<span>(</span><span>database: <a title="nn_analysis.storage.database.Database" href="database.html#nn_analysis.storage.database.Database">Database</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class handling often used storage related queries such as saving results from an experiment or from fitting to a <code>TableSet</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>database</code></strong></dt>
<dd><code>Database</code> the <code>Table</code>s and <code>TableSet</code>s should reside in</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageManager:
    &#34;&#34;&#34;
    Class handling often used storage related queries such as saving results from an experiment or from fitting to a `TableSet`

    Args:
        database: `Database` the `Table`s and `TableSet`s should reside in
    &#34;&#34;&#34;

    database: Database

    def __init__(self, database: Database):
        self.database = database

    def save_result_table_set(self, results: tuple, name: str, table_labels: dict, nrows: int = None,
                              ncols: tuple = None, row_start: int = 0, col_start: int = 0,
                              append_rows: bool = False) -&gt; TableSet:
        &#34;&#34;&#34;
        Function that saves a `TableSet` with the results.
        Results do not have to be complete. If the result is incomplete provide the nrows or ncols parameters.
        The lacking rows or columns will then be filled with zeros. When providing the additional results use the
        row_start and col_start parameters to indicate where the existing TableSet is to be overridden.

        If a result tuple is incomplete and has completely missing parts fill in the missing parts with None values.

        Examples
        ---------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;})
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, nrows=4)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data appended with two rows of zeros in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, ncols=(6,))
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows and four columns of data appended with two columns of zeros in a single subtable
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, row_start=2)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was changed in rows 2 and 3 with the data given here.
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, append_rows=True)
        TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was appended with the two rows given here.

        Args:
            results: A (nested) tuple of np.ndarrays containing results
            name: (str) The name of the `TableSet` to be created or updated
            table_labels: A (nested) dictionary of the names of the `Table`s/`SubTable`s in the `TableSet`
            nrows (optional): Amount of rows that will (eventually) be in the `TableSet`. If not provided `nrows=results.shape[0]`
            ncols (optional): Amount of columns that will (eventually) be in the table set per subpart of the data. If not provided `ncols[i]=results[i].shape[1]`
            row_start (optional, default=0): Int of the row where the results start. This parameter is used if nrows does not match the amount of rows in the results.
            col_start (optional, default=0): Int of the column where the results start. This parameter is used if ncols does not match the amount of columns in the results.
            append_rows (optional, default=False): If true, when the `TableSet` is already initialised the results will be appended as rows to the existing `TableSet`

        Returns:
            `TableSet` containing the results
        &#34;&#34;&#34;
        table_set = TableSet(name, self.database)
        if not __verify_data_types_are_correct__(results):
            raise ValueError(&#39;results is not a tuple of nested tuples of np.ndarrays or a tuple of np.ndarrays!&#39;)
        if not self.__verify_results_and_ncols_shape(results, ncols):
            raise ValueError(&#39;ncols and results should be of the same shape&#39;)
        if self.__requires_nrows_calculation(results, nrows):
            nrows = self.__fetch_nrows_from_partial_result_set(results)
        if ncols is None and self.__requires_ncols_to_be_set_somewhere(results):
            raise ValueError(&#39;When one of the results is None, ncols has to be set for that result!&#39;)
        padded_results = self.__pad_with_zeros(results, ncols, nrows)
        if table_set.initialised:  # Update existing TableSet
            if append_rows:
                table_set.append_rows(padded_results)
            else:
                # Combine the small arrays into one large array so we can use the TableSet update function
                combined_results = self.__combine_into_big_array(padded_results)
                table_set[row_start:combined_results.shape[0]+row_start,
                          col_start:combined_results.shape[1]+col_start] = combined_results
        else:
            table_set.initialise(padded_results, table_labels)
        return table_set

    def open_table(self, name: str):
        &#34;&#34;&#34;
        Opens a `Table` or `TableSet` in the `Database` with the given name.
        The function can automatically distinguish between `Table`s and `TableSet`s.

        Examples
        ----------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).open_table(&#39;Name&#39;)
        Table(&#39;Name&#39;) or TableSet(&#39;Name&#39;) if a `Table` or `TableSet` exists in this database.

        Args:
            name: Name of the `Table` or `TableSet`

        Returns:
            `Table` or `TableSet`
        &#34;&#34;&#34;
        if Table(name, self.database).initialised:
            return Table(name, self.database)
        elif TableSet(name, self.database).initialised:
            return TableSet(name, self.database)
        else:
            raise NoSuchTableError

    def remove_table(self, name: str):
        &#34;&#34;&#34;
        Deletes a table from the `Database`

        Examples
        ----------
        &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).remove_table(&#39;Name&#39;)
        Removes table with the name &#39;Name&#39; from the database at path &#39;path&#39;.

        Args:
            name: The name of the `Table`
        &#34;&#34;&#34;
        if os.path.isdir(self.database.folder + name):
            shutil.rmtree(self.database.folder + name)

    def __requires_nrows_calculation(self, results: tuple, nrows: int = None) -&gt; bool:
        if nrows is not None:
            return False
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                if not self.__requires_nrows_calculation(result):
                    return False
            elif result is None:
                return True
        return False

    def __requires_ncols_to_be_set_somewhere(self, results: tuple):
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                if not self.__requires_nrows_calculation(result):
                    return False
            elif result is None:
                return True
        return False

    def __fetch_nrows_from_partial_result_set(self, results: tuple) -&gt; int:
        for result in results:
            if type(result) is tuple:
                nrows_subresult = self.__fetch_nrows_from_partial_result_set(result)
                if nrows_subresult is not None:
                    return nrows_subresult
            elif result is not None:
                return result.shape[0]
        raise ValueError(&#39;When all results are None values nrows has to be set!&#39;)

    def __verify_results_and_ncols_shape(self, results: tuple, ncols: tuple):
        if ncols is None:
            return True
        if len(ncols) != len(results):
            return False
        i = 0
        for result in results:
            if type(result) is tuple:
                if type(ncols[i]) is not tuple:
                    return False
                if not self.__verify_results_and_ncols_shape(result, ncols[i]):
                    return False
            i += 1
        return True

    def __pad_with_zeros(self, results: tuple, ncols: tuple, nrows: int) -&gt; tuple:
        i = 0
        final_result = []
        for result in results:
            if type(result) is tuple:  # If the result is a tuple unpack it further
                this_ncols = ncols
                if ncols is not None:
                    this_ncols = ncols[i]
                final_result.append(self.__pad_with_zeros(result, this_ncols, nrows))
            elif result is None:  # If the result is None fill the result using the ncols and nrows
                if ncols is None or ncols[i] is None:
                    raise ValueError(&#39;When a particular result is None, ncols for that result has to be set!&#39;)
                final_result.append(np.zeros((nrows, ncols[i])))
            else:  # If the result is a result fit it in a padded result array of shape (ncols, nrows)
                flattened_array = result.reshape(result.shape[0], -1)
                this_nrows = flattened_array.shape[0]
                this_ncols = flattened_array.shape[1]
                if nrows is not None:
                    this_nrows = nrows
                if ncols is not None:
                    this_ncols = ncols[i]
                padded_array = np.zeros((this_nrows, this_ncols))
                padded_array[:, :flattened_array.shape[1]] = flattened_array
                final_result.append(padded_array)
            i += 1
        return tuple(final_result)

    def __combine_into_big_array(self, results: tuple) -&gt; np.ndarray:
        final_result = []
        for result in results:
            if type(result) is tuple:
                final_result.append(self.__combine_into_big_array(result))
            elif result is None:
                continue
            else:
                final_result.append(result)
        return np.concatenate(final_result)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nn_analysis.storage.storage_manager.StorageManager.database"><code class="name">var <span class="ident">database</span> : <a title="nn_analysis.storage.database.Database" href="database.html#nn_analysis.storage.database.Database">Database</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nn_analysis.storage.storage_manager.StorageManager.open_table"><code class="name flex">
<span>def <span class="ident">open_table</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a <code>Table</code> or <code>TableSet</code> in the <code>Database</code> with the given name.
The function can automatically distinguish between <code>Table</code>s and <code>TableSet</code>s.</p>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; StorageManager(Database('path')).open_table('Name')
Table('Name') or TableSet('Name') if a &lt;code&gt;Table&lt;/code&gt; or &lt;code&gt;TableSet&lt;/code&gt; exists in this database.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the <code>Table</code> or <code>TableSet</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Table</code> or <code>TableSet</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_table(self, name: str):
    &#34;&#34;&#34;
    Opens a `Table` or `TableSet` in the `Database` with the given name.
    The function can automatically distinguish between `Table`s and `TableSet`s.

    Examples
    ----------
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).open_table(&#39;Name&#39;)
    Table(&#39;Name&#39;) or TableSet(&#39;Name&#39;) if a `Table` or `TableSet` exists in this database.

    Args:
        name: Name of the `Table` or `TableSet`

    Returns:
        `Table` or `TableSet`
    &#34;&#34;&#34;
    if Table(name, self.database).initialised:
        return Table(name, self.database)
    elif TableSet(name, self.database).initialised:
        return TableSet(name, self.database)
    else:
        raise NoSuchTableError</code></pre>
</details>
</dd>
<dt id="nn_analysis.storage.storage_manager.StorageManager.remove_table"><code class="name flex">
<span>def <span class="ident">remove_table</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a table from the <code>Database</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; StorageManager(Database('path')).remove_table('Name')
Removes table with the name 'Name' from the database at path 'path'.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the <code>Table</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_table(self, name: str):
    &#34;&#34;&#34;
    Deletes a table from the `Database`

    Examples
    ----------
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).remove_table(&#39;Name&#39;)
    Removes table with the name &#39;Name&#39; from the database at path &#39;path&#39;.

    Args:
        name: The name of the `Table`
    &#34;&#34;&#34;
    if os.path.isdir(self.database.folder + name):
        shutil.rmtree(self.database.folder + name)</code></pre>
</details>
</dd>
<dt id="nn_analysis.storage.storage_manager.StorageManager.save_result_table_set"><code class="name flex">
<span>def <span class="ident">save_result_table_set</span></span>(<span>self, results: tuple, name: str, table_labels: dict, nrows: int = None, ncols: tuple = None, row_start: int = 0, col_start: int = 0, append_rows: bool = False) ‑> <a title="nn_analysis.storage.table_set.TableSet" href="table_set.html#nn_analysis.storage.table_set.TableSet">TableSet</a></span>
</code></dt>
<dd>
<div class="desc"><p>Function that saves a <code>TableSet</code> with the results.
Results do not have to be complete. If the result is incomplete provide the nrows or ncols parameters.
The lacking rows or columns will then be filled with zeros. When providing the additional results use the
row_start and col_start parameters to indicate where the existing TableSet is to be overridden.</p>
<p>If a result tuple is incomplete and has completely missing parts fill in the missing parts with None values.</p>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; StorageManager(Database('path')).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), 'TableSetName', {'first':''})
TableSet('TableSetName') &lt;-- &lt;code&gt;TableSet&lt;/code&gt; with the two rows of data in a single subtable
&gt;&gt;&gt; StorageManager(Database('path')).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), 'TableSetName', {'first':''}, nrows=4)
TableSet('TableSetName') &lt;-- &lt;code&gt;TableSet&lt;/code&gt; with the two rows of data appended with two rows of zeros in a single subtable
&gt;&gt;&gt; StorageManager(Database('path')).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), 'TableSetName', {'first':''}, ncols=(6,))
TableSet('TableSetName') &lt;-- &lt;code&gt;TableSet&lt;/code&gt; with the two rows and four columns of data appended with two columns of zeros in a single subtable
&gt;&gt;&gt; StorageManager(Database('path')).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), 'TableSetName', {'first':''}, row_start=2)
TableSet('TableSetName') &lt;-- &lt;code&gt;TableSet&lt;/code&gt; with four rows. The original &lt;code&gt;TableSet&lt;/code&gt; was changed in rows 2 and 3 with the data given here.
&gt;&gt;&gt; StorageManager(Database('path')).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), 'TableSetName', {'first':''}, append_rows=True)
TableSet('TableSetName') &lt;-- &lt;code&gt;TableSet&lt;/code&gt; with four rows. The original &lt;code&gt;TableSet&lt;/code&gt; was appended with the two rows given here.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong></dt>
<dd>A (nested) tuple of np.ndarrays containing results</dd>
<dt><strong><code>name</code></strong></dt>
<dd>(str) The name of the <code>TableSet</code> to be created or updated</dd>
<dt><strong><code>table_labels</code></strong></dt>
<dd>A (nested) dictionary of the names of the <code>Table</code>s/<code>SubTable</code>s in the <code>TableSet</code></dd>
<dt><strong><code>nrows</code></strong> :&ensp;<code>optional</code></dt>
<dd>Amount of rows that will (eventually) be in the <code>TableSet</code>. If not provided <code>nrows=results.shape[0]</code></dd>
<dt><strong><code>ncols</code></strong> :&ensp;<code>optional</code></dt>
<dd>Amount of columns that will (eventually) be in the table set per subpart of the data. If not provided <code>ncols[i]=results[i].shape[1]</code></dd>
<dt><strong><code>row_start</code></strong> :&ensp;<code>optional</code>, default=<code>0</code></dt>
<dd>Int of the row where the results start. This parameter is used if nrows does not match the amount of rows in the results.</dd>
<dt><strong><code>col_start</code></strong> :&ensp;<code>optional</code>, default=<code>0</code></dt>
<dd>Int of the column where the results start. This parameter is used if ncols does not match the amount of columns in the results.</dd>
<dt><strong><code>append_rows</code></strong> :&ensp;<code>optional</code>, default=<code>False</code></dt>
<dd>If true, when the <code>TableSet</code> is already initialised the results will be appended as rows to the existing <code>TableSet</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>TableSet</code> containing the results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_result_table_set(self, results: tuple, name: str, table_labels: dict, nrows: int = None,
                          ncols: tuple = None, row_start: int = 0, col_start: int = 0,
                          append_rows: bool = False) -&gt; TableSet:
    &#34;&#34;&#34;
    Function that saves a `TableSet` with the results.
    Results do not have to be complete. If the result is incomplete provide the nrows or ncols parameters.
    The lacking rows or columns will then be filled with zeros. When providing the additional results use the
    row_start and col_start parameters to indicate where the existing TableSet is to be overridden.

    If a result tuple is incomplete and has completely missing parts fill in the missing parts with None values.

    Examples
    ---------
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;})
    TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data in a single subtable
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, nrows=4)
    TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows of data appended with two rows of zeros in a single subtable
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[1,2,3,4], [2,3,4,5]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, ncols=(6,))
    TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with the two rows and four columns of data appended with two columns of zeros in a single subtable
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, row_start=2)
    TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was changed in rows 2 and 3 with the data given here.
    &gt;&gt;&gt; StorageManager(Database(&#39;path&#39;)).save_result_table_set((np.array([[3,4,5,6], [4,5,6,7]]),), &#39;TableSetName&#39;, {&#39;first&#39;:&#39;&#39;}, append_rows=True)
    TableSet(&#39;TableSetName&#39;) &lt;-- `TableSet` with four rows. The original `TableSet` was appended with the two rows given here.

    Args:
        results: A (nested) tuple of np.ndarrays containing results
        name: (str) The name of the `TableSet` to be created or updated
        table_labels: A (nested) dictionary of the names of the `Table`s/`SubTable`s in the `TableSet`
        nrows (optional): Amount of rows that will (eventually) be in the `TableSet`. If not provided `nrows=results.shape[0]`
        ncols (optional): Amount of columns that will (eventually) be in the table set per subpart of the data. If not provided `ncols[i]=results[i].shape[1]`
        row_start (optional, default=0): Int of the row where the results start. This parameter is used if nrows does not match the amount of rows in the results.
        col_start (optional, default=0): Int of the column where the results start. This parameter is used if ncols does not match the amount of columns in the results.
        append_rows (optional, default=False): If true, when the `TableSet` is already initialised the results will be appended as rows to the existing `TableSet`

    Returns:
        `TableSet` containing the results
    &#34;&#34;&#34;
    table_set = TableSet(name, self.database)
    if not __verify_data_types_are_correct__(results):
        raise ValueError(&#39;results is not a tuple of nested tuples of np.ndarrays or a tuple of np.ndarrays!&#39;)
    if not self.__verify_results_and_ncols_shape(results, ncols):
        raise ValueError(&#39;ncols and results should be of the same shape&#39;)
    if self.__requires_nrows_calculation(results, nrows):
        nrows = self.__fetch_nrows_from_partial_result_set(results)
    if ncols is None and self.__requires_ncols_to_be_set_somewhere(results):
        raise ValueError(&#39;When one of the results is None, ncols has to be set for that result!&#39;)
    padded_results = self.__pad_with_zeros(results, ncols, nrows)
    if table_set.initialised:  # Update existing TableSet
        if append_rows:
            table_set.append_rows(padded_results)
        else:
            # Combine the small arrays into one large array so we can use the TableSet update function
            combined_results = self.__combine_into_big_array(padded_results)
            table_set[row_start:combined_results.shape[0]+row_start,
                      col_start:combined_results.shape[1]+col_start] = combined_results
    else:
        table_set.initialise(padded_results, table_labels)
    return table_set</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nn_analysis.storage" href="index.html">nn_analysis.storage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nn_analysis.storage.storage_manager.StorageManager" href="#nn_analysis.storage.storage_manager.StorageManager">StorageManager</a></code></h4>
<ul class="">
<li><code><a title="nn_analysis.storage.storage_manager.StorageManager.database" href="#nn_analysis.storage.storage_manager.StorageManager.database">database</a></code></li>
<li><code><a title="nn_analysis.storage.storage_manager.StorageManager.open_table" href="#nn_analysis.storage.storage_manager.StorageManager.open_table">open_table</a></code></li>
<li><code><a title="nn_analysis.storage.storage_manager.StorageManager.remove_table" href="#nn_analysis.storage.storage_manager.StorageManager.remove_table">remove_table</a></code></li>
<li><code><a title="nn_analysis.storage.storage_manager.StorageManager.save_result_table_set" href="#nn_analysis.storage.storage_manager.StorageManager.save_result_table_set">save_result_table_set</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>