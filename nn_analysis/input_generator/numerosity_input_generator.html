<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nn_analysis.input_generator.numerosity_input_generator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nn_analysis.input_generator.numerosity_input_generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
from enum import Enum
from typing import List, Optional

try:
    import matplotlib.pyplot as plt
    no_plotting = False
except ImportError:
    plt = None
    no_plotting = True
import numpy as np
from PIL import Image, ImageDraw

from tqdm import tqdm
import math
from ..plot import Plot

from ..storage import StorageManager
from .two_d_input_generator import TwoDInputGenerator


class NumerosityInputGenerator(TwoDInputGenerator):
    &#34;&#34;&#34;Class containing function pertaining to the generation of stimuli encoding for numerosity

    This class is a subclass of the `TwoDInputGenerator` and is responsible for implementing the generation and storage
    of two dimensional numerosity stimuli and the plotting of said stimuli.

    Multiple stimuli are generated for each numerosity for one or multiple different calculation functions.
    The calculation functions are controls for correlating variables with numerosity like the total amount of contrast
    in a stimulus.

    The calculation function can either be area, for a constant total area of all the dots in the image,
    size for a constant dot size, or circumference for a constant total circumference.
    Images are generated with a random dot placement nvar times.

    Attributes:
        nvars: (int) The number of random images that are generated for each numerosity-calculation function pair.
        nrange: (int, int) The range (min, max) of numerosities stimuli will be generated for.
    &#34;&#34;&#34;

    def __init__(self, nvars: int, nrange: (int, int), table: str, storage_manager: StorageManager,
                 verbose: bool = False, calc_functions: Optional[List[str]] = None):
        &#34;&#34;&#34;
        Args:
            nvars: (int) The number of random images that are generated for each numerosity-calculation function pair.
            nrange: (int, int) The range (min, max) of numerosities stimuli will be generated for.
            table: (str) The name of the table the stimuli will be stored to.
            storage_manager: (`StorageManager`) `StorageManager` that will handle the processing of the table
            verbose (optional, default=False): (bool) If yes, will print the process to the console
            calc_functions (optional): List with &#39;area&#39;, &#39;size&#39;, and/or &#39;circumference.
        &#34;&#34;&#34;
        if calc_functions is None:
            calc_functions = [&#39;area&#39;, &#39;size&#39;, &#39;circumference&#39;]
        elif all(elem != &#39;area&#39; and elem != &#39;size&#39; and elem != &#39;circumference&#39; for elem in calc_functions):
            raise ValueError(&#39;Expected calc_functions to only contain \&#39;area\&#39;, \&#39;size\&#39;, or \&#39;circumference\&#39;&#39;)
        self.nvars = nvars
        self.nrange = nrange
        self.__storage_manager = storage_manager
        self.__table = table
        self.__verbose = verbose
        self.__calc_functions = calc_functions
        self.__q = 0

    def _get_2d(self, shape: (int, int), index: int) -&gt; np.ndarray:
        &#34;&#34;&#34;Generates the 2d stimulus to be appended with other dimensions to a complete stimulus.

        Args:
            shape: (int, int) The shape of the 2d stimulus to generate.
            index: (int) The index of the stimulus. The index allows the function to differentiate which variation to generate in a generalisable way.

        Returns:
            (np.ndarray) The generated stimulus as a 2d image.
        &#34;&#34;&#34;
        # Only return one colour channel, all colour channels are equal
        return self.__generate_dot_image(index, shape, self.__calc_functions[self.__q])[:, :, 0]

    def generate(self, shape: tuple):
        &#34;&#34;&#34;Generates the stimuli based on the expected output shape
        It, for each numerosity in `range(self.nrange[0], self.nrange[1)`, for each `self.calc_function`, generates `self.nvar` random placed dot imgaes.
        Finally it saves those images in a `Table` and returns them
        Args:
            shape: (tuple) expected shape of the final stimuli

        Returns:
            (`Table`) The resulting stimuli `Table`
        &#34;&#34;&#34;
        tbl = None
        for n in tqdm(range(self.nrange[0], self.nrange[1]), leave=False, disable=(not self.__verbose)):
            for q in range(len(self.__calc_functions)):
                self.__q = q
                for j in range(0, self.nvars):
                    tbl = self.__storage_manager.save_result_table_set((self._generate_row(shape, n)[np.newaxis, ...],),
                                                                       self.__table, {self.__table: self.__table}, append_rows=True)
        return tbl

    @staticmethod
    def __generate_dot_image(ndots: int, img_shape: (int, int), calculation_function: str = &#39;area&#39;,
                             plt_image: bool = False, plt_title: str = &#39;&#39;):
        &#34;&#34;&#34;Function to randomly generate images displaying a set number of dots using a set calculation function.
        The calculation function determines how the function calculates the size of each individual dot.
        The calculation function can either be area, for a constant total area of all the dots in the image, size for a constant dot size, or circumference for a constant total circumference.

        Args:
            ndots: (int) Number of dots to generate
            img_shape: (int, int) Size of the image
            calculation_function (optional, default=&#39;area&#39;): (str) Way to calculate dot size
            plt_image (optional, default=False): (bool) If True the generated image is plotted (requires matplotlib to be installed)
            plt_title (optional, default=&#39;&#39;): (str) Title used in the plot if plt_image is True

        Returns:
            (np.ndarray) The resulting stimulus
        &#34;&#34;&#34;
        # Parameters
        win_pos = Enum(&#39;win_pos&#39;, &#39;area size circumference&#39;)
        ndots = int(ndots)
        width = int(img_shape[1])
        height = int(img_shape[0])
        dotSize = -1
        dotSizeIn = -1
        recheckDist = -1

        # arg1 check
        if ndots &lt; 0:
            raise ValueError(&#34;ndots must be &gt;= 0&#34;)
        if ndots == 0:
            image = np.zeros((height, width, 3))
            if plt_image:
                plt.imshow(image)
                plt.show()
            return image
        # arg3 check
        if width &lt; 0:
            raise ValueError(&#34;shape[0] must be &gt; 0&#34;)
        if height &lt; 0:
            raise ValueError(&#34;shape[1] must be &gt; 0&#34;)
        # arg4 check
        if calculation_function == &#39;area&#39;:
            params_conditionOrder = win_pos.area
        elif calculation_function == &#39;size&#39;:
            params_conditionOrder = win_pos.size
        elif calculation_function == &#39;circumference&#39;:
            params_conditionOrder = win_pos.circumference
        else:
            raise ValueError(&#34;calculate_function must be [&#39;area&#39;|&#39;size&#39;|&#39;circumference&#39;]&#34;)
        # arg compatibility check
        if dotSize &gt;= width or dotSize &gt;= height:
            raise ValueError(&#34;dot size cannot be greater or equal to image size in pxs&#34;)

        params_equalArea = 1
        # Get Experiment Name
        if params_conditionOrder == win_pos.area:
            params_equalArea = 1
            dotSizeIn = 3 * (7 / 2) ** 2 * math.pi
        elif params_conditionOrder == win_pos.size:
            params_equalArea = 0
            dotSize = 7
        elif params_conditionOrder == win_pos.circumference:
            params_equalArea = 2
            dotSizeIn = 19 * math.pi * 3

        # Get Recheck Distribution Based on ndots
        if params_equalArea == 1:
            dotSize = (2 * (math.sqrt((dotSizeIn / ndots) / math.pi)))
            if ndots == 2:
                recheckDist = 5
            elif ndots == 3:
                recheckDist = 5
            elif ndots == 4:
                recheckDist = 4.8
            elif ndots == 5:
                recheckDist = 4.5
            elif ndots == 6:
                recheckDist = 4.2
            elif ndots == 7:
                recheckDist = 4
            else:
                recheckDist = 3
        elif params_equalArea == 2:
            dotSize = dotSizeIn / ndots / math.pi
            if ndots == 2:
                recheckDist = 1.15
            elif ndots == 3:
                recheckDist = 1.5
            elif ndots == 4:
                recheckDist = 1.9
            elif ndots == 5:
                recheckDist = 2.1
            elif ndots == 6:
                recheckDist = 2.3
            elif ndots == 7:
                recheckDist = 2.5
            else:
                recheckDist = 3
        elif params_equalArea == 0:
            if ndots == 2:
                recheckDist = 6
            elif ndots == 3:
                recheckDist = 5
            elif ndots == 4:
                recheckDist = 4
            elif ndots == 5:
                recheckDist = 3.5
            elif ndots == 6:
                recheckDist = 3
            elif ndots == 7:
                recheckDist = 2.8
            else:
                recheckDist = 1.4

        dotGroup = NumerosityInputGenerator.__new_dot_pattern(ndots, width, height, dotSize, recheckDist)
        return NumerosityInputGenerator.__draw_image(width, height, dotGroup, dotSize, plt_image, plt_title)

    @staticmethod
    def __new_dot_pattern(ndots: int, width: int, height: int, dot_size: float, recheck_dist):
        &#34;&#34;&#34;Function that generates the pattern of where the dots have to be placed.

        Args:
            ndots: (int) Number of dots to generate
            width: (int) Width of the stimulus
            height: (int) Height of the stimulus
            dot_size: (float) Size of the dot
            recheck_dist: Variable that determines how close dots are allowed to be

        Returns:
            Tuple of x,y coords of circle ([1,39], [43,2], ...)
        &#34;&#34;&#34;
        infCounter = 0
        recheckCounter = 1000
        dotGroup = ()
        while recheckCounter == 1000:
            for curdot in range(0, ndots):
                # Dot position, x,y
                # tempDotPattern = [random.uniform(0.1, 0.9) * img_len_px, random.uniform(0.1, 0.9) * img_len_px]
                tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]

                # Get dot pattern that works for img size
                while math.sqrt((tempDotPattern[0] - 0.5 * width) ** 2 + (
                        tempDotPattern[1] - 0.5 * height) ** 2) &gt; 0.5 * math.sqrt(width * height) - dot_size / 2:
                    tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]
                    infCounter = infCounter + 1
                    if infCounter &gt;= 5000:
                        raise ArithmeticError(&#34;fatal error....&#34;)
                A = tempDotPattern[0]
                B = tempDotPattern[1]

                if curdot == 0:
                    dotGroup = (tempDotPattern,)  # make initial tuple
                    recheckCounter = 1
                else:
                    recheck = 1
                    recheckCounter = 1
                    while recheck == 1:
                        recheck = 0
                        for storedDots in range(0, len(dotGroup)):
                            if recheck == 0:
                                xDist = dotGroup[storedDots][0] - A
                                yDist = dotGroup[storedDots][1] - B
                                totalDist = math.sqrt(xDist ** 2 + yDist ** 2)
                                if totalDist &lt; (dot_size * recheck_dist):
                                    recheck = 1

                        if recheck == 0:
                            dotGroup = (*dotGroup, [A, B])
                        else:
                            tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]
                            while math.sqrt((tempDotPattern[0] - 0.5 * width) ** 2 + (
                                    tempDotPattern[1] - 0.5 * height) ** 2) \
                                    &gt; 0.5 * math.sqrt(width * height) - dot_size / 2:
                                tempDotPattern = [random.uniform(0.1, 0.9) * width,
                                                  random.uniform(0.1, 0.9) * height]
                            A = tempDotPattern[0]
                            B = tempDotPattern[1]
                            recheckCounter = recheckCounter + 1
                            if recheckCounter == 1000:
                                raise ArithmeticError(&#34;rechecks exceed maximum, double check parameter tuning&#34;)
        return dotGroup

    @staticmethod
    def __draw_image(img_width: int, image_height: int, dot_group: tuple,
                     dot_size: float, plt_image: bool = False, plt_title: str = &#39;&#39;):
        &#34;&#34;&#34;Generates the actual Image

        Args:
            img_width: (int) Width of image
            image_height: (int) Height of image
            dot_group: (tuple) Tuple of x,y coords of circle ([1,39], [43,2], ...)
            dot_size: (float) Diameter of a single dot.
            plt_image: (bool) If True the generated image is plotted
            plt_title: (str) Title used in the plot if plt_image is True

        Returns:
            np.ndarray containing the image
        &#34;&#34;&#34;

        # make a blank image first
        image = Image.new(&#39;RGB&#39;, (img_width, image_height))
        draw = ImageDraw.Draw(image)

        r = np.ceil(dot_size / 2)
        for dot in dot_group:
            draw.ellipse((np.ceil(dot[0] - r), np.ceil(dot[1] - r), np.ceil(dot[0] + r), np.ceil(dot[1] + r)), fill=(255, 255, 255))

        image = np.array(image)
        if plt_image and not no_plotting:
            plt.imshow(image, origin=&#39;lower&#39;)
            if Plot.save_fig:
                Plot.title = plt_title
            else:
                plt.title(plt_title)
            Plot.show(plt)
            Plot.title = None
        elif plt_image and no_plotting:
            print(&#39;Matplotlib not found. Skipping image plotting.&#39;)

        return image</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator"><code class="flex name class">
<span>class <span class="ident">NumerosityInputGenerator</span></span>
<span>(</span><span>nvars: int, nrange: (<class 'int'>, <class 'int'>), table: str, storage_manager: <a title="nn_analysis.storage.storage_manager.StorageManager" href="../storage/storage_manager.html#nn_analysis.storage.storage_manager.StorageManager">StorageManager</a>, verbose: bool = False, calc_functions: Union[List[str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class containing function pertaining to the generation of stimuli encoding for numerosity</p>
<p>This class is a subclass of the <code>TwoDInputGenerator</code> and is responsible for implementing the generation and storage
of two dimensional numerosity stimuli and the plotting of said stimuli.</p>
<p>Multiple stimuli are generated for each numerosity for one or multiple different calculation functions.
The calculation functions are controls for correlating variables with numerosity like the total amount of contrast
in a stimulus.</p>
<p>The calculation function can either be area, for a constant total area of all the dots in the image,
size for a constant dot size, or circumference for a constant total circumference.
Images are generated with a random dot placement nvar times.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>nvars</code></strong></dt>
<dd>(int) The number of random images that are generated for each numerosity-calculation function pair.</dd>
<dt><strong><code>nrange</code></strong></dt>
<dd>(int, int) The range (min, max) of numerosities stimuli will be generated for.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nvars</code></strong></dt>
<dd>(int) The number of random images that are generated for each numerosity-calculation function pair.</dd>
<dt><strong><code>nrange</code></strong></dt>
<dd>(int, int) The range (min, max) of numerosities stimuli will be generated for.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>(str) The name of the table the stimuli will be stored to.</dd>
<dt><strong><code>storage_manager</code></strong></dt>
<dd>(<code>StorageManager</code>) <code>StorageManager</code> that will handle the processing of the table</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>optional</code>, default=<code>False</code></dt>
<dd>(bool) If yes, will print the process to the console</dd>
<dt><strong><code>calc_functions</code></strong> :&ensp;<code>optional</code></dt>
<dd>List with 'area', 'size', and/or 'circumference.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumerosityInputGenerator(TwoDInputGenerator):
    &#34;&#34;&#34;Class containing function pertaining to the generation of stimuli encoding for numerosity

    This class is a subclass of the `TwoDInputGenerator` and is responsible for implementing the generation and storage
    of two dimensional numerosity stimuli and the plotting of said stimuli.

    Multiple stimuli are generated for each numerosity for one or multiple different calculation functions.
    The calculation functions are controls for correlating variables with numerosity like the total amount of contrast
    in a stimulus.

    The calculation function can either be area, for a constant total area of all the dots in the image,
    size for a constant dot size, or circumference for a constant total circumference.
    Images are generated with a random dot placement nvar times.

    Attributes:
        nvars: (int) The number of random images that are generated for each numerosity-calculation function pair.
        nrange: (int, int) The range (min, max) of numerosities stimuli will be generated for.
    &#34;&#34;&#34;

    def __init__(self, nvars: int, nrange: (int, int), table: str, storage_manager: StorageManager,
                 verbose: bool = False, calc_functions: Optional[List[str]] = None):
        &#34;&#34;&#34;
        Args:
            nvars: (int) The number of random images that are generated for each numerosity-calculation function pair.
            nrange: (int, int) The range (min, max) of numerosities stimuli will be generated for.
            table: (str) The name of the table the stimuli will be stored to.
            storage_manager: (`StorageManager`) `StorageManager` that will handle the processing of the table
            verbose (optional, default=False): (bool) If yes, will print the process to the console
            calc_functions (optional): List with &#39;area&#39;, &#39;size&#39;, and/or &#39;circumference.
        &#34;&#34;&#34;
        if calc_functions is None:
            calc_functions = [&#39;area&#39;, &#39;size&#39;, &#39;circumference&#39;]
        elif all(elem != &#39;area&#39; and elem != &#39;size&#39; and elem != &#39;circumference&#39; for elem in calc_functions):
            raise ValueError(&#39;Expected calc_functions to only contain \&#39;area\&#39;, \&#39;size\&#39;, or \&#39;circumference\&#39;&#39;)
        self.nvars = nvars
        self.nrange = nrange
        self.__storage_manager = storage_manager
        self.__table = table
        self.__verbose = verbose
        self.__calc_functions = calc_functions
        self.__q = 0

    def _get_2d(self, shape: (int, int), index: int) -&gt; np.ndarray:
        &#34;&#34;&#34;Generates the 2d stimulus to be appended with other dimensions to a complete stimulus.

        Args:
            shape: (int, int) The shape of the 2d stimulus to generate.
            index: (int) The index of the stimulus. The index allows the function to differentiate which variation to generate in a generalisable way.

        Returns:
            (np.ndarray) The generated stimulus as a 2d image.
        &#34;&#34;&#34;
        # Only return one colour channel, all colour channels are equal
        return self.__generate_dot_image(index, shape, self.__calc_functions[self.__q])[:, :, 0]

    def generate(self, shape: tuple):
        &#34;&#34;&#34;Generates the stimuli based on the expected output shape
        It, for each numerosity in `range(self.nrange[0], self.nrange[1)`, for each `self.calc_function`, generates `self.nvar` random placed dot imgaes.
        Finally it saves those images in a `Table` and returns them
        Args:
            shape: (tuple) expected shape of the final stimuli

        Returns:
            (`Table`) The resulting stimuli `Table`
        &#34;&#34;&#34;
        tbl = None
        for n in tqdm(range(self.nrange[0], self.nrange[1]), leave=False, disable=(not self.__verbose)):
            for q in range(len(self.__calc_functions)):
                self.__q = q
                for j in range(0, self.nvars):
                    tbl = self.__storage_manager.save_result_table_set((self._generate_row(shape, n)[np.newaxis, ...],),
                                                                       self.__table, {self.__table: self.__table}, append_rows=True)
        return tbl

    @staticmethod
    def __generate_dot_image(ndots: int, img_shape: (int, int), calculation_function: str = &#39;area&#39;,
                             plt_image: bool = False, plt_title: str = &#39;&#39;):
        &#34;&#34;&#34;Function to randomly generate images displaying a set number of dots using a set calculation function.
        The calculation function determines how the function calculates the size of each individual dot.
        The calculation function can either be area, for a constant total area of all the dots in the image, size for a constant dot size, or circumference for a constant total circumference.

        Args:
            ndots: (int) Number of dots to generate
            img_shape: (int, int) Size of the image
            calculation_function (optional, default=&#39;area&#39;): (str) Way to calculate dot size
            plt_image (optional, default=False): (bool) If True the generated image is plotted (requires matplotlib to be installed)
            plt_title (optional, default=&#39;&#39;): (str) Title used in the plot if plt_image is True

        Returns:
            (np.ndarray) The resulting stimulus
        &#34;&#34;&#34;
        # Parameters
        win_pos = Enum(&#39;win_pos&#39;, &#39;area size circumference&#39;)
        ndots = int(ndots)
        width = int(img_shape[1])
        height = int(img_shape[0])
        dotSize = -1
        dotSizeIn = -1
        recheckDist = -1

        # arg1 check
        if ndots &lt; 0:
            raise ValueError(&#34;ndots must be &gt;= 0&#34;)
        if ndots == 0:
            image = np.zeros((height, width, 3))
            if plt_image:
                plt.imshow(image)
                plt.show()
            return image
        # arg3 check
        if width &lt; 0:
            raise ValueError(&#34;shape[0] must be &gt; 0&#34;)
        if height &lt; 0:
            raise ValueError(&#34;shape[1] must be &gt; 0&#34;)
        # arg4 check
        if calculation_function == &#39;area&#39;:
            params_conditionOrder = win_pos.area
        elif calculation_function == &#39;size&#39;:
            params_conditionOrder = win_pos.size
        elif calculation_function == &#39;circumference&#39;:
            params_conditionOrder = win_pos.circumference
        else:
            raise ValueError(&#34;calculate_function must be [&#39;area&#39;|&#39;size&#39;|&#39;circumference&#39;]&#34;)
        # arg compatibility check
        if dotSize &gt;= width or dotSize &gt;= height:
            raise ValueError(&#34;dot size cannot be greater or equal to image size in pxs&#34;)

        params_equalArea = 1
        # Get Experiment Name
        if params_conditionOrder == win_pos.area:
            params_equalArea = 1
            dotSizeIn = 3 * (7 / 2) ** 2 * math.pi
        elif params_conditionOrder == win_pos.size:
            params_equalArea = 0
            dotSize = 7
        elif params_conditionOrder == win_pos.circumference:
            params_equalArea = 2
            dotSizeIn = 19 * math.pi * 3

        # Get Recheck Distribution Based on ndots
        if params_equalArea == 1:
            dotSize = (2 * (math.sqrt((dotSizeIn / ndots) / math.pi)))
            if ndots == 2:
                recheckDist = 5
            elif ndots == 3:
                recheckDist = 5
            elif ndots == 4:
                recheckDist = 4.8
            elif ndots == 5:
                recheckDist = 4.5
            elif ndots == 6:
                recheckDist = 4.2
            elif ndots == 7:
                recheckDist = 4
            else:
                recheckDist = 3
        elif params_equalArea == 2:
            dotSize = dotSizeIn / ndots / math.pi
            if ndots == 2:
                recheckDist = 1.15
            elif ndots == 3:
                recheckDist = 1.5
            elif ndots == 4:
                recheckDist = 1.9
            elif ndots == 5:
                recheckDist = 2.1
            elif ndots == 6:
                recheckDist = 2.3
            elif ndots == 7:
                recheckDist = 2.5
            else:
                recheckDist = 3
        elif params_equalArea == 0:
            if ndots == 2:
                recheckDist = 6
            elif ndots == 3:
                recheckDist = 5
            elif ndots == 4:
                recheckDist = 4
            elif ndots == 5:
                recheckDist = 3.5
            elif ndots == 6:
                recheckDist = 3
            elif ndots == 7:
                recheckDist = 2.8
            else:
                recheckDist = 1.4

        dotGroup = NumerosityInputGenerator.__new_dot_pattern(ndots, width, height, dotSize, recheckDist)
        return NumerosityInputGenerator.__draw_image(width, height, dotGroup, dotSize, plt_image, plt_title)

    @staticmethod
    def __new_dot_pattern(ndots: int, width: int, height: int, dot_size: float, recheck_dist):
        &#34;&#34;&#34;Function that generates the pattern of where the dots have to be placed.

        Args:
            ndots: (int) Number of dots to generate
            width: (int) Width of the stimulus
            height: (int) Height of the stimulus
            dot_size: (float) Size of the dot
            recheck_dist: Variable that determines how close dots are allowed to be

        Returns:
            Tuple of x,y coords of circle ([1,39], [43,2], ...)
        &#34;&#34;&#34;
        infCounter = 0
        recheckCounter = 1000
        dotGroup = ()
        while recheckCounter == 1000:
            for curdot in range(0, ndots):
                # Dot position, x,y
                # tempDotPattern = [random.uniform(0.1, 0.9) * img_len_px, random.uniform(0.1, 0.9) * img_len_px]
                tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]

                # Get dot pattern that works for img size
                while math.sqrt((tempDotPattern[0] - 0.5 * width) ** 2 + (
                        tempDotPattern[1] - 0.5 * height) ** 2) &gt; 0.5 * math.sqrt(width * height) - dot_size / 2:
                    tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]
                    infCounter = infCounter + 1
                    if infCounter &gt;= 5000:
                        raise ArithmeticError(&#34;fatal error....&#34;)
                A = tempDotPattern[0]
                B = tempDotPattern[1]

                if curdot == 0:
                    dotGroup = (tempDotPattern,)  # make initial tuple
                    recheckCounter = 1
                else:
                    recheck = 1
                    recheckCounter = 1
                    while recheck == 1:
                        recheck = 0
                        for storedDots in range(0, len(dotGroup)):
                            if recheck == 0:
                                xDist = dotGroup[storedDots][0] - A
                                yDist = dotGroup[storedDots][1] - B
                                totalDist = math.sqrt(xDist ** 2 + yDist ** 2)
                                if totalDist &lt; (dot_size * recheck_dist):
                                    recheck = 1

                        if recheck == 0:
                            dotGroup = (*dotGroup, [A, B])
                        else:
                            tempDotPattern = [random.uniform(0.1, 0.9) * width, random.uniform(0.1, 0.9) * height]
                            while math.sqrt((tempDotPattern[0] - 0.5 * width) ** 2 + (
                                    tempDotPattern[1] - 0.5 * height) ** 2) \
                                    &gt; 0.5 * math.sqrt(width * height) - dot_size / 2:
                                tempDotPattern = [random.uniform(0.1, 0.9) * width,
                                                  random.uniform(0.1, 0.9) * height]
                            A = tempDotPattern[0]
                            B = tempDotPattern[1]
                            recheckCounter = recheckCounter + 1
                            if recheckCounter == 1000:
                                raise ArithmeticError(&#34;rechecks exceed maximum, double check parameter tuning&#34;)
        return dotGroup

    @staticmethod
    def __draw_image(img_width: int, image_height: int, dot_group: tuple,
                     dot_size: float, plt_image: bool = False, plt_title: str = &#39;&#39;):
        &#34;&#34;&#34;Generates the actual Image

        Args:
            img_width: (int) Width of image
            image_height: (int) Height of image
            dot_group: (tuple) Tuple of x,y coords of circle ([1,39], [43,2], ...)
            dot_size: (float) Diameter of a single dot.
            plt_image: (bool) If True the generated image is plotted
            plt_title: (str) Title used in the plot if plt_image is True

        Returns:
            np.ndarray containing the image
        &#34;&#34;&#34;

        # make a blank image first
        image = Image.new(&#39;RGB&#39;, (img_width, image_height))
        draw = ImageDraw.Draw(image)

        r = np.ceil(dot_size / 2)
        for dot in dot_group:
            draw.ellipse((np.ceil(dot[0] - r), np.ceil(dot[1] - r), np.ceil(dot[0] + r), np.ceil(dot[1] + r)), fill=(255, 255, 255))

        image = np.array(image)
        if plt_image and not no_plotting:
            plt.imshow(image, origin=&#39;lower&#39;)
            if Plot.save_fig:
                Plot.title = plt_title
            else:
                plt.title(plt_title)
            Plot.show(plt)
            Plot.title = None
        elif plt_image and no_plotting:
            print(&#39;Matplotlib not found. Skipping image plotting.&#39;)

        return image</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nn_analysis.input_generator.two_d_input_generator.TwoDInputGenerator" href="two_d_input_generator.html#nn_analysis.input_generator.two_d_input_generator.TwoDInputGenerator">TwoDInputGenerator</a></li>
<li><a title="nn_analysis.input_generator.input_generator.InputGenerator" href="input_generator.html#nn_analysis.input_generator.input_generator.InputGenerator">InputGenerator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, shape: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the stimuli based on the expected output shape
It, for each numerosity in <code>range(self.nrange[0], self.nrange[1)</code>, for each <code>self.calc_function</code>, generates <code>self.nvar</code> random placed dot imgaes.
Finally it saves those images in a <code>Table</code> and returns them</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shape</code></strong></dt>
<dd>(tuple) expected shape of the final stimuli</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(<code>Table</code>) The resulting stimuli <code>Table</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, shape: tuple):
    &#34;&#34;&#34;Generates the stimuli based on the expected output shape
    It, for each numerosity in `range(self.nrange[0], self.nrange[1)`, for each `self.calc_function`, generates `self.nvar` random placed dot imgaes.
    Finally it saves those images in a `Table` and returns them
    Args:
        shape: (tuple) expected shape of the final stimuli

    Returns:
        (`Table`) The resulting stimuli `Table`
    &#34;&#34;&#34;
    tbl = None
    for n in tqdm(range(self.nrange[0], self.nrange[1]), leave=False, disable=(not self.__verbose)):
        for q in range(len(self.__calc_functions)):
            self.__q = q
            for j in range(0, self.nvars):
                tbl = self.__storage_manager.save_result_table_set((self._generate_row(shape, n)[np.newaxis, ...],),
                                                                   self.__table, {self.__table: self.__table}, append_rows=True)
    return tbl</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nn_analysis.input_generator" href="index.html">nn_analysis.input_generator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator" href="#nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator">NumerosityInputGenerator</a></code></h4>
<ul class="">
<li><code><a title="nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator.generate" href="#nn_analysis.input_generator.numerosity_input_generator.NumerosityInputGenerator.generate">generate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>